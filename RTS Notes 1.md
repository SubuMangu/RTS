# Ch 1
- **Definition:** A real time system means the system is subjected to real time i.e, the response should be guaranteed within a specified timing constraint or the system should need the specified deadline.
- A system is called **real time system** when we need quantitative expression of time(i.e, real time) to describe behaviour of the system (book definition).

## Basic Model of RTS
- Here we will discuss about the underlying hardware model behind real time system
- The sensors are interfaced with input conditioning block, which in turn is connected to input interface.
- The output interface ,output conditioning and the actuator are interfaced in a complementary manner.

<img src="Images/Screenshot 2024-11-29 154311.png" width="" height="">

1. **Sensor:** A sensor converts the physical characteristics of the environment to electrical signals.Eg,Pressure sensors operates based on piezoelectricity principle.Temperature sensor senses temperature by using the concept of variation of resistance with temperature.
2. **Actuator:** An actuator is a new device that takes its inputs from the output interface of a computer and converts these electrical signals into some physical actions on its environment.The physical actions may be in the form of motion, change in thermal ,electrical pneumatic or physical characteristics of some objects.
3. **Signal Conditioning units:**
- When signals are transferred from sensor to computer and then to the actuator, the input signal from sensor cannot be directly accepted by computer and electrical signals from computer cannot be directly accepted by actuator.
- These signal need to be conditioned before passing in both the cases.
- Conditioning of signals can be performed in several ways as listed below
    - **Voltage amplification:** It is required to match the full scale sensor voltage output with full scale voltage input to the interface of a computer. Eg, A sensor might produce voltage in few millivolts range, whereas the input interface of a computer may require signal level to be of the order of a volt.
    - **Voltage level shifting:** It is often required to align the voltage level generated by a sensor with that acceptable to the computer. Example a sensor may produce voltage range from -0.5 to +0.5 volt,Whereas the input interface of a computer may accept voltage only in range of 0 to 1 volt.
    - **Frequency range shifting and filtering:** It is used to reduce noise components in a signal.Many types of noise occur in narrow bands, and the signal must be shifted from noise bands so that noise can be filtered out.
    - **Signal mode conversion:** A type of signal mode conversion that is frequently carried out during signal conditioning involves changing direct current to alternating current and vice versa.
        - Another type of signal conversion that is frequently used is the conversion of analog signals to a constant amplitude pulse trains such that the pulse rate, or pulse width, is proportional to the voltage level.It is often necessary for input to systems such as *transformer coupled circuits* that do not pass direct current.
4. **Interface unit:** 
- Commands from CPU are delivered to the actuator through an output interface.
- The output interface has 2 components:Data Register and Digital to Analog Converter

<img src="Images/Screenshot 2024-11-29 161327.png" width="" height="">

- The CPU selects a data register of the output interface and writes the necessary data to it.
- The digital to analog converter in output interface converts the stored data to analog form and then output these to the actuator circuitry.
- The input interface converts the analog signal from sensor to digital signals.

## Types of Real Time Systems
1. **Hard RTS**
- A hard real time task is one that is constrained to produce its results within certain predefined time bounds.
- The system fails on missing its deadline to avoid any disastrous events.
- **Example:** Flight Controller Systems
2. **Soft RTS**
- This type of system can miss its deadline occasionally with some acceptability
- Missing the deadline have no disastrous consequences 
- But the value decreases as it crosses the deadline

<img src="Images/Screenshot 2024-11-24 105058.png" width="" height="">

- **Example:** Telephone Switches
3. **Firm RTS:**
- These are systems that lie between hard and soft RTS.
- Unlike like hard real time. The system doesn't fail on missing its deadline, but the late results are discarded.

<img src="Images/Screenshot 2024-11-24 105221.png" width="" height="">

- **Example:** Online trading system ,Online auction system ,Online reservation system

**Advantages of RTS**
- RTS provides *immediate and accurate responses* to external events by making them suitable for critical applications such as medical equipments, industrial automation and air traffic control.
- It can *reduce human error* by automating task that require precision, accuracy and consistency.
- They can *automate complex tasks* that would otherwise be impossible to perform manually, thus improving productivity and efficiency
- They can help to *reduce cost* by minimising the need of human intervention and reducing risk of errors.
- RTS can be *customised* to meet specific requirements, making them ideal for wide range of applications

**Disadvantages of RTS**
- RTS are *vulnerable to failures* and malfunction, which can have serious consequences in critical applications.
- RTS require *careful planning and management*, as they must continually monitor and maintain to ensure they operate correctly.
- RTS are typically *less flexible* than other types of computer systems, as they must adhere to strike timing requirements and cannot be easily modified or adapted to changing circumstances.
- They are very *expensive* to develop as they require *specific hardware*.
- RTS can be *complex and difficult to design, implement and test* requiring specialised skills and expertise.

## Characteristics of RTS(Refer pg no.9-12 in book)
- There are eight characteristics of real time systems:
1. **Time constraints:** Every real time systems are associated with time constraints or deadlines. It is the responsibility of the real time operating system to ensure all the tasks meet their respective time constraints. RTOS meet this time constraints using task scheduling strategies.
2. **Correctness:** In real time systems correctness implies not only logical correctness of the result, but the time at which the result are produced is important. A logically correct result produced after the deadline would be considered as incorrect result.
3. **Embedded:** In embedded systems, there is a specific set of hardware programed to perform a particular task.
- In real time systems it has. It has actuators, sensors and real time computer, Where sensors take physical input from the environment the computer processes it and the actuator gives the physical output.
4. **Safety-Critical:** Safe system is the one that doesn't cause any damage when it fails.
- The reliable system, on the other hand, is the one that can operate for long durations of time without exhibiting any failure.
- A safety critical system required to be highly reliable since any failure of the system can cause extensive damage.
- Many real time systems are safety critical systems
5. **Concurrency:** Realtime system must process data from all sensors concurrently. Otherwise, deadline would be missed, and system may malfunction.
6. **Fault Tolerance:** 
7. Real Time Communication
8. Security and Scalability

## Timing Constraints in Real Time Systems
- Timing constraint related with RTS simply means that time interval allocated for the response of the ongoing programme.
- RTS is responsible for completion of all tasks within their time interval.
- Timing constraint is a vital attribute in RTS. It decides total correctness of the result in RTS.
- The correctness of results in RTS doesn't depend only on logical correctness, but also on the results should be obtained within the time constraint.
- There might be several events happening in rts. These events are scheduled by scheduler using timing constraints.
1. **Performance Constraint**
- The constraint enforced on the response of the system is known as performance constraint.
- This basically describes the overall performance of the system.
2. **Behavioural Constraint**
- The constraint enforced to the stimuli generated by the environment. It ensures that environment of the system should be well behaved.
- Performance and behavioural constraints are further classified into three important categories.
    1. Delay Constraint
    2. Duration Constraint
    3. Deadline Constraint

<img src="Images/Screenshot 2024-11-24 103916.png" width="" height="">

**Delay Constraints**
- It describes the minimum time interval between occurrence of two consecutive events in real time system.
- If an event occurs below the delay constraint, then it is called **delay violation**.

<img src="Images/Screenshot 2024-11-24 120905.png" width="" height="">

**Deadline constraint**
- It describes the maximum time interval between occurrence of two consecutive events
- In real time systems, if an event occurs after the deadline constraint, then the result of event is considered incorrect.

<img src="Images/Screenshot 2024-11-24 121013.png" width="" height="">

**Durational constraint**
- It specifies a time period over which an event acts.

**Events in real time system**

**Stimulus events:** 
- These events are generated by the environment and act on the system.
- These events can be produced asynchronously (i.e. aperiodically)
- **Example:** When the user presses a button on a telephone set, generates a stimulus event to act on the telephone system.

**Response events:**
- Response events are usually produced by the system in response to some stimulus events.

- Deadline and Delay constraints are divided into 4 types(pg no 22)

# Ch 2
## Some Imp Concepts(pg no-31-33)
- **Task instance:** Each time an event occurs, it triggers the task that handles this event to run.Each time a task reoccurs is called the instance of task.
- The **absolute deadline** of a task is the absolute time value (counter from time 0) by which results are expected. 
- **Relative deadline** is the time interval between the start of the task and the instant at which deadline occurs
- **Response time** is the time duration from occurrence of the event generating the task to the time produces its results
- **Task precedence:** 
- A task is said to precede another task if the first task must complete before the start of second task.
- It is represented by continuous arrow.
- **Data sharing:** 
- It is represented by dotted arrow.
- It is not necessary that sharing between two task occur if one task is preceeded by the other. They can be overlapping and concurrent.

## Types of Real Time Tasks(pg no 33-35)
- Based on the way real time tasks reoccur over a period of time, it is possible to classify them into three main categories
- For notation refer textbook.
1. **Perodic tasks:** 
- A periodic task repeats after a fixed time interval.The fixed time interval, after which a task repeats is called the *period* of the task.
- Vast majority of tasks present in a typical real time system are periodic.The reason for this is that many activities carried out by real time systems are periodic in nature For example, monitoring certain conditions, polling information from sensors at regular intervals to carry out certain accent at regular intervals.
2. **Sporadic task:**
- sporadic task is the one that reoccurs at random instances having same deadline, but constraints on minimum separation between two tasks is applied.
- These tasks are used to handle emergency situations which needs certain minimum amount of time to be handled.
3. **Aperiodic Tasks**
- Here tasks reoccur at random instances and there is no constraints applied on separation among these tasks.
- Here task instances can have distinct deadlines
- Here tasks instances can also overlap or occur concurrently.
- These tasks are generally soft real time tasks.It is because if they overlap or occur concurrently.Hence difficult to satisfy deadline of all tasks in this situation.

## Task Scheduling(pg no 35-36)
- Real time task scheduling essentially refers to determining the order in which various tasks are picked up for execution by the os.
- Every OS relies on one or more task schedulers to prepare the schedule for execution of various tasks needed to run.
- Each task scheduler is categorised by scheduling algorithm.
- A large number of algorithms for real time scheduling task has been developed so far are listed below.
1. Valid scheduler 
2. Feasible scheduler
3. Proefficient scheduler
4. Optimal schedulers
5. Preemptive scheduler
6. Non preemptive scheduler


# Ch 3
## Resourse Sharing in RTS
- Real-time tasks often need to share resources, which must be used exclusively by one task at a time.
- **Nonpreemptable Resources:** Some resources, like files, devices, or data structures, are nonpreemptable (cannot be interrupted while in use).These are also known as **critical resources** or **critical sections**.
- **Serially Reusable Resources:** A task using a serially reusable resource can be interrupted and resume later without issues.Examples include CPUs
- Nonpreemptable resources cannot be interrupted; otherwise, corruption or inconsistency occurs.
- Serially reusable resources, like CPUs, allow tasks to be preempted safely.
- **Challenge with Nonpreemptable Resources:**
    - Lower-priority tasks using nonpreemptable resources block higher-priority tasks until they finish.
    - Traditional algorithms like EDF and RMA, designed for serially reusable resources, struggle to manage nonpreemptable resources effectively.
- **System Stability Risk:** Improper handling of nonpreemptable resources can lead to system failure.
## Priority Inversion
- Priority inversion is a bug in RTOS that occurs when a lower priority task prevents a high priority task from executing.
- Priority inversion refers to a bug where higher priority task is delayed due to lower priority task holding shared resource.
- This can lead to a missed deadline and potentially dangerous outcome for the end users.
- **Unbounded priority inversion** is an important problem that real-time system developers face. For example, a real-time application with high priority tasks TH and low priority tasks TL may face unbounded priority inversions when intermediate priority tasks preempt the low priority task from CPU usage. This can result in the high priority task waiting for the required resource for a considerable period of time, or even indefinitely.
- This can be tackled by **priority inheritance protocol(PIP)**

## PIP(Priority inheritance protocol)
- The basic concept of pip is that when a task goes through a priority inversion, the priority of the lower priority task which has the critical resource is increased by priority inheritance mechanism
- It allows this task to use critical resource as early as possible, without going through preemption by intermediate priority tasks.
- Hence, it avoids unbounded priority inversion.

**Working of PIP**
1. When several tasks are waiting for the same critical resource, the task which is currently holding this resource is given the highest priority among all the tasks which are waiting for the same critical resource.
2. Now, after the lower priority tasks, having the critical resource is given the highest priority, then the intermediate cannot preempt this task. This helps in avoiding unbounded priority inversion.
3. If a task is holding multiple critical resources then, after releasing one critical resource, it cannot back to its original priority value.It will restore its original priority value only after releasing all the critical resources.

**Advantages of PIP**
- The most prominent advantage with PIP is it avoids unbounded priority inversion.
- It allows different priority tasks to share the critical resources.

**Disadvantages**
- **Deadlock:** 
- Chain blocking
- Starvation(as a result of chained blocking)
# Ch 4
## Scheduling Real Time tasks in Multiprocessors and Distributed Systems
- Use of multiprocessor and distributed systems in real time applications is becoming popular.
- The reason for this popularity is the recent drop in prices of these systems.
- Eg, Now dual processor machines are available at 50 to 60,000 rs and the prices are set to drop further.
- Another reason that attracts real time system developers to deploy multiprocessor and distributed systems is the **faster response time** and **fault tolerance features**
- Further distributed processing is often suitable for applications that are naturally distributed and the event of interest are generated at geographically distributed locations.The example of such an application is an automated petroleum refinery where the plant is spread over a considerable geographically area.
- Multiprocessor systems are **tightly coupled systems**.  This characteristics of multiprocessor systems denotes the existence of shared physical memory in the system.
- In contrast, distributed systems are **loosely coupled systems** and is devoid of any shared physical memory.
- Scheduling real time tasks on distributed and multi processor systems consists of two sub problems
    1. **task allocation** to processors 
    2. **scheduling tasks** on individual processors.
- The task assignment problem is concerned with how to partition a set of tasks and then how to assign these to the processors. Task assignment can either be static or dynamic. 
- In the **static allocation scheme**, the allocation of tasks to nodes is permanent and does not change with time. 
- Whereas in the **dynamic task assignment**, tasks are assigned to nodes as they run. Thus, in the dynamic case, different instances of a task may be allocated to different nodes.
- The task allocation to processors in multiprocessor and distributed environments is an NP-hard problem and determining an optimal solution has exponential complexity.
- So, most of the algorithms that are deployed in practice are heuristic algorithms. 
- In static algorithms all the tasks are partitioned into subsystems. Each subsystem is assigned to a separate processor.
- In contrast, in a dynamic system tasks ready for execution are placed in one common priority queue and dispatched to processors for execution as the processors become available. 
- It is therefore possible that different instances of periodic tasks execute on different processors. 
- Most hard real time systems are static in nature, since processors are already allocated to tasks before execution.Hence, reduces the time required for allocating task while running.
- However, dynamic real time system can make more efficient utilisation of available resources.
### Multiprocessor Task Allocation
- 
### Dynamic Allocation of Tasks
- Dynamic algorithms assume that any task can be executed on any processor. 
- Many of the dynamic solutions are naturally distributed and do not assume that there is a central allocation policy running on some processor.
- In the dynamic algorithms, rather than preallocating tasks to processors, the tasks are assigned to processors as and when they arise.
- Since the task allocation to nodes can be made on the instantaneous load position of the nodes, the achievable schedulable utilization in this case should be better than the static approaches.
- However, the dynamic approach incurs high run time overhead since the allocator component running at every node needs to keep track of the instantaneous load position at every other node
- In contrast, in a static task allocation algorithm, tasks are permanently assigned to processors at the system initialization time and no overhead is incurred during run time.
- 
# Ch 5
## Real Time OS
- A real time operating system is primarily responsible for ensuring every real time task meet its timeliness requirements.
- A real time operating system achieve this by using appropriate task scheduling techniques.
- In this type of system, processing must be done inside the specified constraints, otherwise the system will fail.



